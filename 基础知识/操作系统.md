###### 死锁 ######

根本原因

- 系统资源有限。
- 进程推进顺序不合理

四个必要条件

- 互斥： 某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- 占有且等待： 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
- 不可抢占： 别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
- 循环等待： 存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

避免死锁的方法：预防，避免，（诊断和解除）

预防死锁发生就是破坏产生死锁的条件

- 一次封锁法
  要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

   存在的问题：降低系统的并发度；难以实现精确确定封锁对象

- 顺序封锁法

  预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。 

  存在的问题： 维护成本：数据库系统中的封锁对象极多，并且在不断地变化

银行家算法

死锁的诊断：超时法和事务等待图法

- 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁 

  优点：实现简单 

  缺点：误判死锁；时限若设置太长，死锁发生后不能及时发现

- 事务等待图法：用事务等待图动态反映所有事务的等待情况事务

死锁的解除

- 并发控制子系统选择一个处理死锁代价最小的事务，将其撤销。 释放该事务持有的所有的锁，使其他事务能够继续运行下去

###### 进程通信方式 ######

1. 管道
2. 信号量
4. 套接字

###### 内存管理机制 ######

1. **块式管理** ：  远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段氏管理**：每个段定义了一组逻辑信息

###### 虚拟内存的技术实现 ######

1. **请求分页存储管理**  ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
2. **请求分段存储管理**  ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. **请求段页式存储管理**

###### 页面置换算法 ######

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal,  OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Currently Used）页面置换算法（最久未使用页面置换算法）** ：最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** :  选择在之前时期使用最少次数的页面作为淘汰页。

###### 虚拟地址 ######

使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。

没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存 。出现以下问题

1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。
2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址  1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ  音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。

通过虚拟地址访问内存有以下优势：

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。（由内存管理单元进行实际的地址转换）

###### 快表 ######

快表其中的内容是页表的一部分或者全部内容。采用页表做地址转换，读写内存数据时 CPU  要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。