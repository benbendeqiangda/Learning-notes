###### 三次握手 ######

- 如果客户端已经连接超时失败，放弃连接了。这个时候超时的信号又到了服务端，服务第二次握手，认为建立了连接，服务器资源就被浪费了。
- 通过通信双方数据原点的序列号，确认双方都已经建立连接

###### 网络七层 ######

应用层，表示层，会话层，传输层，网络层（网际层），数据链路层，物理层组成。

传输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。

###### 子网掩码 ######

用来区分网络号和主机号

网络号：区分一个组织的编码

主机号：区分一个组织内部的编码

###### 输入网址到网页显示 ######

1. 进行DNS（Domain Name System，域名系统）查询，将域名转化为具体的ip地址。

   1. 首先会在浏览器缓存中去查询，之前每浏览一个网站，浏览器都会在缓存中存有域名与ip地址的映射关系。
   2. 浏览器缓存中查询不到后，之后会在系统缓存中查询，由浏览器发起一个系统调用，查询系统缓存中的数据。
   3. 系统缓存中也查询不到后，将会去路由器缓存中查找。
   4. 路由器缓存中也找不到的话，将会从本地DNS服务器的缓存中查找，本地服务器即用户自己配置的DNS服务器。
   5. 如果本地的DNS服务器也找不到的话，本地DNS将会发送请求至根域名服务器，根域名服务器中没有相关缓存数据的时候，就会返回com顶级域名服务器的地址。然后本地DNS服务器再发送请求至com顶级域名服务器，com顶级域名服务器中查询不到的话，就会返回baidu权威服务器的地址，然后本地DNS服务器再发送请求至baidu权威服务器，baidu权威服务器就会返回www主机地址。（这是一种迭代的过程，还有一种递归的过程。即local至根域名，根域名不直接返回com地址，而是发送请求至com，com发送请求至baidu，baidu发送请求至www，www再返回给baidu，baidu返回给com，com再返回给local）至此，整个DNS查询步骤结束，现在浏览器拿到了域名对应的ip地址。

2. 建立TCP链接

   1. 拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，

3. 浏览器向WEB服务器发起Http请求

   建立TCP连接之后，发起HTTP请求，请求一般分为三部分

   请求方法URI协议/版本

   请求头(Request Header)

   请求正文

4. 关闭TCP链接

5. 浏览器解析资源

###### get和post ######

GET上要在url之外带一些参数就只能依靠url上附带querystring：当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。

浏览器的POST请求都来自表单提交：每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是"key1=value1&key2=value2"这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。

浏览器在POST一个表单时，url上也可以带参数，只要<form action="url" >里的url带querystring就行。只不过表单里面的那些用<input> 等标签经过用户操作产生的数据都在会在body里。

因此我们一般会**泛泛的说**“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。

###### http和tcp ######

- http基于tcp

- http是应用层，考虑的是数据格式。tcp是传输层，考虑的是数据如何正确的传输

- http是无状态的，在没有状态的 http 协议下，服务器也一 定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。

  TCP 是有状态的，因为每一条消息的 seq 和 ack（还有一堆滑动窗口， 拥塞的控制参数，等）都和前面消息相关。

###### HTTPS和HTTP ######

- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

- http和https使用用端口不一样，前者是80，后者是443。

- 通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。SSL 不仅提供**加密**处理， 而且还使用了一种被称为证书的手段，可用于**确定双方身份**。

- SSL 是独立于 HTTP 的协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。


###### TCP 长连接和短连接 ######

TCP 短连接是指客户端与服务端连接后只进行一次读写就关闭连接，一般是客户端关闭。
而长连接则是指在进行完一次读写后不关闭连接，直到服务端压力过大则选择关闭一些长时间为进行读写的连接。

- TCP 短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。

- TCP 长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。


###### TCP 粘包、拆包 ######

- 粘包：一个数据包的数据量很少，两个数据包被一起放在缓存接受
- 拆包：一个数据包中的数据量超过了缓冲器的大小，被拆成两个包

TCP 之所以会产生粘包和拆包拆包问题，是因为他本身就是一种字节流协议，TCP 本身就没有数据包的概念，需要发送和接受的数据是没有格式的，以字节流的形式传输，而在传输过程中会被分割为一段段数据块，也就是报文。TCP 要发送的数据会被先放置在数据缓冲区，接收数据也是从缓冲区获取，而缓冲区的大小即为最大报文长度

解决方案

- 在数据包头加上数据包长度
- 把每个数据包封装为固定长度，不够则补 0
- 使用特定分割符号

###### TCP 可靠性 ######

- 在数据包层面：校验和
- 在数据包传输层面：序列号、确认应答、超时重传
- 在流量控制层面：拥塞控制

###### tcp和udp ######

- TCP 是面向连接的，UDP 是面向无连接的
- TCP 保证数据正确性，无差错，不丢失，不重复，且按序到达。UDP 不保证可靠交付。
- TCP是一种流模式的协议，UDP是一种数据报模式的协议
- 每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。

##### 拥塞控制 #####

###### 慢开始 ######

慢开始强调的是开始的报文段少，从1个报文段开始，x2增长

###### 拥塞避免 ######

线性增长

###### 快重传 ######

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。

快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

###### 快恢复  ######

当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免

##### time_wait #####

在四次挥手过程中，有如下过程:                                          

1. HOST1上的应用程序关闭己方的连接导致TCP发送一个FIN消息给HOST2。
2. HOST2发送一个确认消息给HOST1,并且HOST2把FIN作为EOF递交给HOST2上的应用程序。
3. 一段时间过后，HOST2上的应用程序关闭它那边的连接，引发一个FIN消息给HOST1。
4. HOST1给HOST2发送一个确认消息，然后HOST2关闭连接并释放资源，然而，HOST1却没有关闭连接，而是进入了TIME_WAIT状态，并为两个最大段生存时间(2MSL)，保留在此状态.

###### 为什么需要time_wait ######

- TIME_WAIT维护连接状态保证会接收到HOST2重新发送的FIN消息：因为在第四步的时候，HOST1发送的ACK可能丢失并导致HOST2重新发送FIN消。如果 A 端不维持 TIME_WAIT 状 态，而是处于 CLOSED 状态，那么 A 端将响应 RST 报文，B 端收到后将此报文解释成一个 错误（在 java 中会抛出 connection reset 的 SocketException)。

- 一个TCP连接不能打开两个以上，TIME_WAIT维护连接状态防止连接重用：TCP报文可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个报文，迷途的报文在路由器修复后也会被送到最终目的地。如果两个相同主机之间又建立了一个具有相同端口号的新连接，那么重传段就可能被看成是新连接的，如果重传段中数据的任何序列号恰恰在新连接的当前接收窗口中，数据就会被重新接收，其结果就是破坏新连接。

  而因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。

#### http协议 ####

就是一个浏览器和服务器之间通信的协议，规定信息传输的格式，符合格式的才会被浏览器进行解析

###### 无连接 ######

无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。

早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。

随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

###### 无状态 ######

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。

即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何这个连接发送的信息。

缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。

客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。

#### http攻击

HTTP：数据的明文传送，缺乏消息完整性检测，身份校验

- 攻击者可以截获HTTP流量，HTTP流量本身是明文的，攻击者用肉眼就可以知道用户的密码、银行卡信息、浏览习惯，根本不用进行任何的分析就可以获取用户的隐私。
- 很多用户浏览某个网页的时候，经常发现页面上弹出一个广告，而这个广告和访问的网页根本毫无关系，这种攻击主要是ISP（互联网服务提供商）发动的一个攻击，用户根本没有任何办法防护。用户访问网站的时候肯定经过ISP, ISP为了一些目的，比如获取广告费用，在响应中插入一段HTML代码，就导致了该攻击的产生。这种攻击称为主动攻击，也就是攻击者知晓攻击的存在

#### https

HTTPS：数据保密性，数据完整性，身份校验

- 散列函数

  散列函数（hash function）是将任意长度的输入转化为定长输出的算法。散列函数的结果经常被简称为散列（hash）

  散列函数最常用的使用场合是以紧凑的方式表示并比较大量数据。比如，为了避免直接比较两个文件，你可以比较它们的散列。散列函数经常被称为指纹、消息摘要，或者简单称为摘要。

- 消息验证代码（messageauthentication code, MAC）：使用密钥的散列（keyed-hash）

  MAC通常与加密一起使用。如果没有MAC，即使攻击者无法解码密文，她也能修改传输中的数据；加密提供了机密性但无法确保完整性。

###### 对称加密

就是加密和解密都是用同一个秘钥，这种方式优点就是速度快，缺点就是在管理和分配秘钥的时候不安全。

###### 非对称加密算法

非对称加密（asymmetric encryption）又称为公钥加密（public key cryptography），它使用两个密钥，其中一个密钥是私密的，另一个是公开的。一个密钥用于私人，另一个密钥将会被所有人共享。**这两个密钥之间存在一些特殊的数学关系，如果你利用某人的公钥加密数据，那么只有他们对应的私钥能够解密。另一个方面，如果某人用私钥加密数据，任何人都可以利用对应的公钥解开消息。后面这种操作不提供机密性，但可以用作数字签名。**

公钥密非常**缓慢**，不适用于数据量大的场景。因此，它往往被部署于进行身份验证和共享秘密的协商，这些秘密后续将用于快速的对称加密。

###### 数字签名

数字签名就是**对散列进行加密**，用来验证发送方的身份。前面描述的MAC就是一种电子签名，它可以利用事先安全交换的散列密钥验证真实性。虽然这种校验非常有用，但仍有不足，因为它仍然依赖于一个私有密钥。

如果使用非对称加密算法，**也需要确定文档来源的公钥**（这就是下面的证书的作用）。

为了验证签名，接收方使用公钥对消息进行解密，将文档和散列解码出来，对文档使用相同的hash算法对原始文档计算hash，确认解密出的散列是否与本地计算的相同。

###### 证书

证书解决如何获得文档来源者公钥的问题（能否信任这个公钥）

直观的看，证书包括以下这些内容：

    1. 证书序列号
    2. 证书过期时间
    3. 站点组织名
    4. 站点DNS主机名
    5. 站点公钥
    6. 证书颁发机构（certification authority或certificate authority, CA）
    7. 证书签名

- 证书内容会被散列算法hash计算出hash值，然后服务器使用CA机构提供的**私钥对hash签名进行RSA加密**（这一步是数字签名，只有拥有私钥的人能够生成正确的证书，从而可以保证证书的来源是可以被确定的）。
- 当客户端发起请求时，服务器将该数字证书发送给客户端，浏览器从你的证书中**找到了颁发者，然后找到CA证书**，它包含了公钥、公钥拥有者名称（CA证书是浏览器自带的，每一种浏览器认可的CA 集合不一样，当一家CA出了什么问题，会被浏览器拉黑，**关键就在于这个CA证书是原始自带的**），客户端通过CA机构提供的公钥对加密密文进行解密获得证书内容和hash值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。

###### 流程

    1. 浏览器首先向服务器发起请求
    2. 服务器响应浏览器，并将自己的证书传递给浏览器
    3. 浏览器验证证书的合法性，**获得证书中的公钥**，**生成本地的sessionKey**，这个key今后会被用来用作对称加密，浏览器用证书中的公钥加密这个sessionKey并发送到服务器
    4. 服务器使用自身私钥解密出sessionKey
    5. 后续的传输只需要建立在http上，双方都使用这个sessionKey做对称加解密就能完成整个通信

前两步会协商协议版本，加密方法等等