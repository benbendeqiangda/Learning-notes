- 面向对象的三个特性：封装；继承；多态

- 普通 for 循环时不能删除元素，否则会抛出异常；Iterator 可以

- 子类的构造函数可否不使用 super(父类构造方法参数)调用超类的构造方法？ 

  可以不用显式的写出 super，但前提是“父类中有多个构造方法，且有一个是显式写出的无参 的构造方法”。
  
- 静态代码块和静态变量是按照书写顺序执行的

###### sql注入

###### 在多线程的场景下如何实现数据库增删改查

###### 设计模式原则 ######

[设计模式六大原则（1）：单一职责原则](http://www.uml.org.cn/sjms/201211023.asp#1)

[设计模式六大原则（2）：里氏替换原则](http://www.uml.org.cn/sjms/201211023.asp#2)

[设计模式六大原则（3）：依赖倒置原则](http://www.uml.org.cn/sjms/201211023.asp#3)

[设计模式六大原则（4）：接口隔离原则](http://www.uml.org.cn/sjms/201211023.asp#4)

[设计模式六大原则（5）：迪米特法则](http://www.uml.org.cn/sjms/201211023.asp#5)

[设计模式六大原则（6）：开闭原则](http://www.uml.org.cn/sjms/201211023.asp#6)

###### String ######

- String str = new String(“ABC”);

  至少创建一个对象，也可能两个。因为用到new关键字，肯定会在heap中创建一个str2的String对象，它的value是“ABC”。同时如果这个字符串在字符串常量池里不存在，会在池里创建这个String对象“ABC”。

- String str1 = “ABC”;可能创建一个或者不创建对象，如果”ABC”这个字符串在java String池里不存在，会在java String池里创建一个创建一个String对象(“ABC”)，然后str1指向这个内存地址，无论以后用这种方式创建多少个值为”ABC”的字符串对象，始终只有一个内存地址被分配，之后的都是String的拷贝，Java中称为“字符串驻留”，所有的字符串常量都会在编译之后自动地驻留。

- 注意只有字符串常量是共享的，+和substring等操作的结果不是共享的，substring也会在堆中重新创建字符串。

###### 外部排序 ######

外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序。

#### 红黑树 ####

它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。

- 性质1：每个节点要么是黑色，要么是红色。

- 性质2：根节点是黑色。

- 性质3：每个叶子节点（NIL）是黑色。（其中Nil为null节点）

- 性质4：每个红色结点的两个子结点一定都是黑色。

- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**

- 从性质5又可以推出：

  性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点

- 黑结点可以同时包含一个红子结点和一个黑子结点

红黑树并不是一个*完美*平衡二叉查找树，但任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为**黑色完美平衡**。

**红黑树总是通过旋转和变色达到自平衡**。

##### 红黑树查找 #####

因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：

- 从根结点开始查找，把根结点设置为当前结点；
- 若当前结点为空，返回null；
- 若当前结点不为空，用当前结点的key跟查找key作比较；
- 若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
- 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
- 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；

由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性